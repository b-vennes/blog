"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[943],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var r=a.createContext({}),s=function(e){var n=a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(r.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,h=d["".concat(r,".").concat(u)]||d[u]||m[u]||o;return t?a.createElement(h,l(l({ref:n},c),{},{components:t})):a.createElement(h,l({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=d;var p={};for(var r in n)hasOwnProperty.call(n,r)&&(p[r]=n[r]);p.originalType=e,p.mdxType="string"==typeof e?e:i,l[1]=p;for(var s=2;s<o;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6014:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const o={tags:["Functional-Programming","Scala","Software-Architecture"],draft:!1},l="Typeclasses and Ad-Hoc Polymorphism",p={permalink:"/2021/06/22/typeclass-and-ad-hoc-polymorphism",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-06-22-typeclass-and-ad-hoc-polymorphism.md",source:"@site/blog/2021-06-22-typeclass-and-ad-hoc-polymorphism.md",title:"Typeclasses and Ad-Hoc Polymorphism",description:"Typeclasses are a construct for declaring categorical behavior on types in the Haskell programming language, however,",date:"2021-06-22T00:00:00.000Z",formattedDate:"June 22, 2021",tags:[{label:"Functional-Programming",permalink:"/tags/functional-programming"},{label:"Scala",permalink:"/tags/scala"},{label:"Software-Architecture",permalink:"/tags/software-architecture"}],readingTime:11.14,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["Functional-Programming","Scala","Software-Architecture"],draft:!1},prevItem:{title:"Building A Blog With Scala Mdoc And Docusaurus",permalink:"/2022/11/07/mdoc-blog"},nextItem:{title:"Building HTML with Python",permalink:"/2020/03/09/building-html-with-python"}},r={authorsImageUrls:[]},s=[{value:"Typeclass Implementations Across Languages",id:"typeclass-implementations-across-languages",level:3},{value:"Scala",id:"scala",level:4},{value:"C#",id:"c",level:4},{value:"Typescript",id:"typescript",level:4},{value:"Rust",id:"rust",level:4},{value:"Helpful Typeclasses",id:"helpful-typeclasses",level:3},{value:"Eq",id:"eq",level:4},{value:"Show",id:"show",level:4},{value:"Monoid",id:"monoid",level:4},{value:"Functor",id:"functor",level:4},{value:"Monad",id:"monad",level:4},{value:"Conclusion",id:"conclusion",level:2}],c={toc:s};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Typeclasses are a construct for declaring categorical behavior on types in the Haskell programming language, however,\nthe concept is not restricted to just Haskell.  The typeclass is an implementation of ad-hoc polymorphism, which\nunlike with interface or class inheritance, allows us to define polymorphic behavior on the fly."),(0,i.kt)("p",null,"Typeclasses provide an abstraction by defining interfaces and the ",(0,i.kt)("em",{parentName:"p"},"values")," that implement them.  In most\nobject-oriented languages, interfaces are defined using direct inheritance from a child type to a parent type.\nInstead of operating on the class level, typeclasses define an interface, then instantiate the implementation in the\nform of a value.  This allows flexibility with interface implementation, since the typeclass instances can be\ninterchanged through function parameters and package imports. With typeclasses, library consumers have the ability to\nextend the functionality of types without modifying the source."),(0,i.kt)("p",null,"A typeclass consists of some generic interface and an implementation for a particular type.  The type can be any\nrepresentation of a value (ex. ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Person"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Vehicle"),"...) and the value itself can be anything.  The most\nimportant part of a typeclass is that the implementation exists seperately from the implementation of the value itself\nand can be used like a value."),(0,i.kt)("h3",{id:"typeclass-implementations-across-languages"},"Typeclass Implementations Across Languages"),(0,i.kt)("p",null,"For the following implementation examples, we will be implementing the\n",(0,i.kt)("a",{parentName:"p",href:"https://typelevel.org/cats/typeclasses/semigroup.html"},"Semigroup")," typeclass on ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," types."),(0,i.kt)("p",null,"Semigroup defines a single ",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," function that takes two instances of type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," as inputs and outputs their combined\nvalue."),(0,i.kt)("p",null,"For example, calling ",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," with the integers ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," should return ",(0,i.kt)("inlineCode",{parentName:"p"},"10")," if we are using addition as the\n",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," implementation (we could also implement this for multiplication)."),(0,i.kt)("p",null,"As an example of how typeclasses can be used within a library, I'll also be creating a function ",(0,i.kt)("inlineCode",{parentName:"p"},"applyTo")," that will\ncombine each value in a list with a given value. For the input ",(0,i.kt)("inlineCode",{parentName:"p"},"List(1, 2, 3, 4, 5)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"applyTo")," with a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"8"),"\nwould return ",(0,i.kt)("inlineCode",{parentName:"p"},"List(9, 10, 11, 12, 13)"),"."),(0,i.kt)("p",null,"It is an implicit requirement that a ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup"),"'s combine operation also be associative: combining a\ngroup of values can occur in any order as in ",(0,i.kt)("inlineCode",{parentName:"p"},"(1 + 2) + 3 = 1 + (2 + 3)"),". However, this is not a possible restriction in\nmost programming languages, so it will not be factored into these examples."),(0,i.kt)("h4",{id:"scala"},"Scala"),(0,i.kt)("p",null,"Although there is not first-class support for typeclasses in Scala, there are language constructs to help create them."),(0,i.kt)("p",null,"We first create a trait representing our ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," typeclass, then create a typeclass instance representing integer\naddition, and finally create a function which implicitly takes a typeclass instance as a parameter.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit"),"\nkeyword in Scala 2 lets us create a value in the implicit scope and summon it when the typeclass is requested."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Semigroup[T] {\n    def combine(a: T, b: T): T\n}\n\nimplicit val intAdditionSemigroup: Semigroup[Int] = (a: Int, b: Int) => a + b\n// intAdditionSemigroup: Semigroup[Int] = repl.MdocSession$MdocApp$$anonfun$1@511ab661\n\ndef applyTo[A](values: List[A], value: A)(implicit semigroup: Semigroup[A]): List[A] =\n    values.map(v => semigroup.combine(v, value))\n\napplyTo(List(1, 2, 3, 4, 5), 8)\n// res0: List[Int] = List(9, 10, 11, 12, 13)\n")),(0,i.kt)("h4",{id:"c"},"C#"),(0,i.kt)("p",null,"Typeclasses in C# require some creativity because anonymous objects aren't a thing.  To access typeclass instances, we\nwill provide an ",(0,i.kt)("inlineCode",{parentName:"p"},"instance")," static method which returns a singleton typeclass instance.  Although this will make it\ndifficult to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup<T>")," typeclass in a generic context, it makes the code a little bit neater."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface Semigroup<T>\n{\n    T Combine(T a, T b);\n}\n\npublic class IntAdditionSemigroup : Semigroup<int>\n{\n    public static IntSemigroup instance = new IntSemigroup();\n\n    public int Combine(int a, int b) = a + b;\n}\n\npublic List<T> ApplyTo<T>(Semigroup<T> instance, List<T> values, T value)\n{\n    return values.Select(v => instance.combine(v, value));\n}\n\nApplyTo(IntAdditionSemigroup.instance, new List<int> { 1, 2, 3, 4, 5 }, 8);\n")),(0,i.kt)("p",null,"Note that because C# has no equivalent of the implicit scope found in Scala, the semigroup instance must be provided\ndirectly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplyTo")," function."),(0,i.kt)("h4",{id:"typescript"},"Typescript"),(0,i.kt)("p",null,"Typescript's implementation is a little neater, but also requires passing the semigroup instance directly because an\n",(0,i.kt)("inlineCode",{parentName:"p"},"implicit")," scope doesn't exist. Typescript ",(0,i.kt)("em",{parentName:"p"},"does")," support instantiating anonymous objects, which makes creating the\ntypeclass instances simple."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Semigroup<T> {\n    combine(a: T, b: T): T\n}\n\nconst numberAdditionSemigroup = {\n    combine(a: number, b: number): number {\n        return a + b\n    }\n} as Semigroup<number>\n\nfunction combineAll<T>(instance: Semigroup<T>, values: T[], value: T): T[] {\n    return values.map(v => instance.combine(v, value))\n}\n\ncombineAll(numberAdditionSemigroup, [1, 2, 3, 4, 5], 8)\n")),(0,i.kt)("h4",{id:"rust"},"Rust"),(0,i.kt)("p",null,"Rust supports Ad-Hoc polymorphism out of the box since the implementation of interfaces for types must be defined\nseparately from the types themselves.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"trait")," implementations in Rust act just like typeclass definitions with an\naccompying ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," block for instance definitions."),(0,i.kt)("p",null,"I've made the ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," typeclass receive the values ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," by reference so that we don't have to take ownership\nof the values, which makes it easier to work with."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"trait Semigroup {\n    fn combine(a: &Self, b: &Self) -> Self;\n}\n\nimpl Semigroup for i32 {\n    fn combine(a: &i32, b: &i32) -> i32 {\n        a + b\n    }\n}\n\nfn apply_to<T>(values: Vec<T>, value: T) -> Vec<T> where T: Semigroup {\n    values.iter().map(|v| { T::combine(&v, &value) } ).collect()\n}\n\napply_to(vec![1, 2, 3, 4, 5], 8)\n")),(0,i.kt)("p",null,"We do not have the option to provide multiple implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," within the same scope, so any\nadditional implementations of ",(0,i.kt)("inlineCode",{parentName:"p"},"combine")," (multiplication) would have to be placed in a separate scope and imported."),(0,i.kt)("h3",{id:"helpful-typeclasses"},"Helpful Typeclasses"),(0,i.kt)("p",null,"There are a number of common typeclasses that can be combined to implement similar behavior across all implementing\ntypes.  ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Show")," are simple typeclasses, but more complex ones like ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," can provide a lot of additional functionality."),(0,i.kt)("p",null,"I will be implmenting the following examples with Scala, but symmetric implementations can be made for C#, Typescript,\nand Rust using the methods outlined in our ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," example."),(0,i.kt)("h4",{id:"eq"},"Eq"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," provides a typesafe equals method ",(0,i.kt)("inlineCode",{parentName:"p"},"eqv"),".  ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," should be used when we want to check that the value of two\nvalues with the same type is the same.  Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"eqv")," with two values of different types should fail to compile."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Eq[T] {\n    def eqv(a: T, b: T): Boolean\n}\n")),(0,i.kt)("p",null,"Because we provide a function that determines if two values are equal, we also get a function determining if two\nvalues are not equal for free."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Eq {\n    def neqv[T](a: T, b: T)(implicit eq: Eq[T]): Boolean = !eq.eqv(a, b)\n}\n")),(0,i.kt)("p",null,"For implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"neqv")," I've created a companion class which takes an implicit ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," instance. The ",(0,i.kt)("inlineCode",{parentName:"p"},"neqv")," method can\nalso be defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," trait itself."),(0,i.kt)("p",null,"Then in our library, we can use our type-safe ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," implementation instead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," which can vary in accuracy\ndepending on type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def combineIfNotEqual[T](a: T, b: T, otherwise: T)(implicit eq: Eq[T], semigroup: Semigroup[T]): T =\n    if (Eq.neqv(a, b)) semigroup.combine(a, b)\n    else otherwise\n")),(0,i.kt)("h4",{id:"show"},"Show"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Show")," provides a method to get an explicit function for turning a value into a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," type.  This is very helpful\nwhen we want to print the state of a complex object to the console without having to override any existing toString\nmethod directly on the type implementation.  Also, when a function wants to print the value of a generic type to the\nconsole, it can use its ",(0,i.kt)("inlineCode",{parentName:"p"},"Show")," implementation instead of relying on the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," method to be correct. Often,\nthe default ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," method will print out garbage, expecially for complex class instances in the JVM."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Show[T] {\n    def show(value: T): String\n}\n")),(0,i.kt)("p",null,"Then, when we want to do some debugging from a function we write, we can require an explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"Show")," implementation\nwhich the function caller provides."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'implicit val showInt: Show[Int] = (value: Int) => s"Integer($value)" // ex. Integer(5)\n// showInt: Show[Int] = repl.MdocSession$MdocApp$$anonfun$2@569034d3 // ex. Integer(5)\n\ndef print[T](value: T)(implicit show: Show[T]): Unit = println(show.show(value))\n\nprint(500)\n// Integer(500)\n')),(0,i.kt)("p",null,"For a more complex object, this can save us a lot of headache."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'class PersonWithRandomAge(val first: String, val last: String) {\n  private val random = scala.util.Random\n\n  val age = random.nextInt(100)\n}\n\nimplicit val showPerson: Show[PersonWithRandomAge] = (person: PersonWithRandomAge) =>\n  s"Person(name: ${person.last}, ${person.first}, age: ${person.age})"\n// showPerson: Show[PersonWithRandomAge] = repl.MdocSession$MdocApp$$anonfun$3@60db59b2\n')),(0,i.kt)("p",null,"Even better, with some help from the Scala Cats library, we can use this implementation when we have a collection of\npeople without any extra work. We just have to be sure to implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"cats.Show")," trait instead of our custom ",(0,i.kt)("inlineCode",{parentName:"p"},"Show")," trait."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.implicits._\n\nimplicit val catsShowPerson: cats.Show[PersonWithRandomAge] = (person: PersonWithRandomAge) =>\n  s"Person(name: ${person.last}, ${person.first}, age: ${person.age})"\n// catsShowPerson: cats.Show[PersonWithRandomAge] = repl.MdocSession$MdocApp$$anonfun$4@37badfd6\n\nval people: List[PersonWithRandomAge] = List(new PersonWithRandomAge("Kup", " Quickdew"), new PersonWithRandomAge("Hellweed", "Underhill"))\n// people: List[PersonWithRandomAge] = List(\n//   repl.MdocSession$MdocApp$PersonWithRandomAge@732baf42,\n//   repl.MdocSession$MdocApp$PersonWithRandomAge@694377d9\n// )\n\npeople.show\n// res2: String = "List(Person(name:  Quickdew, Kup, age: 88), Person(name: Underhill, Hellweed, age: 13))"\n')),(0,i.kt)("h4",{id:"monoid"},"Monoid"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," typeclass is an extension of ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," with an additional method ",(0,i.kt)("inlineCode",{parentName:"p"},"empty")," that returns a value\nrepresenting the default state of non-existence.  For integers, this value would be ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or for strings ",(0,i.kt)("inlineCode",{parentName:"p"},'""'),"."),(0,i.kt)("p",null,"It is often helpful to extend the functionality of one typeclass with that of another.\nWe can expand on our previous ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," trait to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Semigroup[T] {\n  def combine(a: T, b: T): T\n}\n\ntrait Monoid[T] extends Semigroup[T] {\n  def empty: T\n}\n")),(0,i.kt)("p",null,"Any implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," can be used where a ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," is required.\nThis comes in handy when we want to fold over a collection of values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"implicit val intAdditionMonoid: Monoid[Int] = new Monoid[Int] {\n    override def combine(a: Int, b: Int): Int = a + b\n    override def empty: Int = 0\n}\n// intAdditionMonoid: Monoid[Int] = repl.MdocSession$MdocApp3$$anon$1@4d18e5ed\n\ndef combineAll[T](values: List[T])(implicit monoid: Monoid[T]) =\n    values.foldLeft(monoid.empty)(monoid.combine)\n\ncombineAll(List(1, 2, 3, 4, 5)) // 15\n// res4: Int = 15\n")),(0,i.kt)("h4",{id:"functor"},"Functor"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," typeclass defines a ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," method from type ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to type ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," so that a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor[A]")," can be mapped to a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Functor[B]")," type.  This is loosely related to the mathematical definition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," which defines a\nmapping from a set ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to a set ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"F[idA] -> F[idB]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"F[g * f] -> F[g] * F[f]"),".  In this definition,\nthe identity element ",(0,i.kt)("inlineCode",{parentName:"p"},"idA")," depends on the identity of the the category (",(0,i.kt)("inlineCode",{parentName:"p"},"0")," for integer addtion and ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," for integer\nmultiplication) and ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," are functions applied to the element contained in ",(0,i.kt)("inlineCode",{parentName:"p"},"F"),".  For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"g(x) = x + 1"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"f(x) = x + 5"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"F[g(f(3))]")," must be equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"F[g(3)] + F[f(3)]"),"."),(0,i.kt)("p",null,"For the typeclass definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),', we are going to take advantage of Scala\'s ability to define generic type\narguments with a number of "holes".  For example, ',(0,i.kt)("inlineCode",{parentName:"p"},"Functor[F[_]]")," defines a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," type for a generic argument named\n",(0,i.kt)("inlineCode",{parentName:"p"},"F")," that itself has a single type argument.  In most languages, this restriction will not be possible, which can make\ndefining this ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," type tricky."),(0,i.kt)("p",null,"In our example, I will use ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," as the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," argument.  ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," in Scala contains a previously defined ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\nmethod, but I will instead show how the implementation works using just ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," case classes."),(0,i.kt)("p",null,"I'm also adding an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," object with a summoner function which pulls the given implicit functor out\nof the ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit")," scope.  This will let us call the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," map function directly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Functor[F[_]] {\n    def map[A, B](functorA: F[A], mapping: A => B): F[B]\n}\n\nobject Functor {\n    // summoner function\n    def apply[F[_]](implicit functor: Functor[F]): Functor[F] = functor\n}\n\nimplicit val optionFunctor: Functor[Option] = new Functor[Option] {\n    override def map[A, B](functorA: Option[A], mapping: A => B): Option[B] =\n        functorA match {\n            case Some(a) => Some(mapping(a))\n            case None => None\n        }\n}\n// optionFunctor: Functor[Option] = repl.MdocSession$MdocApp3$$anon$2@7731cdb1\n\nFunctor[Option].map[Int, Int](Some(50), x => x * 10)\n// res5: Option[Int] = Some(value = 500)\nFunctor[Option].map[Int, Int](None, x => x * 10)\n// res6: Option[Int] = None\n")),(0,i.kt)("h4",{id:"monad"},"Monad"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," typeclass is an extension on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," typeclass which provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten")," function.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten"),"\nfunction squashes a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"F[F[_]]")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"F[_]"),".  Once defined, we can combine ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," to create\n",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap"),", which works like ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," except it takes in a function of type ",(0,i.kt)("inlineCode",{parentName:"p"},"A => F[B]")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"A => B")," and returns\nthe type ",(0,i.kt)("inlineCode",{parentName:"p"},"F[B]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"trait Monad[F[_]] extends Functor[F] {\n  def flatten[A](nestedFunctorA: F[F[A]]): F[A]\n\n  def flatMap[A, B](functorA: F[A], mapping: A => F[B]): F[B] = flatten(map(functorA, mapping))\n}\n\nimplicit val listMonad: Monad[List] = new Monad[List] {\n  override def map[A, B](functorA: List[A], mapping: A => B): List[B] = functorA match {\n    case head :: tail => mapping(head) :: map(tail, mapping)\n    case _ => List()\n  }\n\n  override def flatten[A](nestedFunctorA: List[List[A]]): List[A] = nestedFunctorA match {\n    case head :: tail => head ++ flatten(tail)\n    case _ => List()\n  }\n}\n// listMonad: Monad[List] = repl.MdocSession$MdocApp3$$anon$3@1528be6b\n\nobject Monad {\n  // summoner function\n  def apply[F[_]](implicit monad: Monad[F]): Monad[F] = monad\n}\n\nMonad[List].map(List(100, 5, 22), (x: Int) => x * 5)\n// res7: List[Int] = List(500, 25, 110)\n\nMonad[List].flatten(List(List(1, 3, 4), List(9, 18, 0)))\n// res8: List[Int] = List(1, 3, 4, 9, 18, 0)\n\nMonad[List].flatMap(List(1, 2, 3, 4), (x: Int) => List(x % 2, x % 3))\n// res9: List[Int] = List(1, 1, 0, 2, 1, 0, 0, 1)\n")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Typeclasses are a flexible and functional approach to abstraction and generic programming.  They are type-safe, modular,\nand simple to test and relieve many headaches software developers encounter with common behaviors on types."))}m.isMDXComponent=!0}}]);